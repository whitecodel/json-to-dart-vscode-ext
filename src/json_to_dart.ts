interface O{n?:boolean;m?:boolean;f?:boolean;p?:boolean;g?:boolean;numForNumber?:boolean;}function sS(i:string){i=i.replace(/^[^a-zA-Z0-9]+/,'');i=i.replace(/[^a-zA-Z0-9]+(.)/g,(m,p1)=>p1.toUpperCase());i=i.replace(/[^a-zA-Z0-9]+$/,'');return i;}function gDCF(jS:string,o:O,cN:string='GeneratedModel',gC:Map<string,{dC:string;j:Map<string,any>;}>=new Map<string,{dC:string;j:Map<string,any>;}>(),):string{let jO:Map<string,any>=JSON.parse(jS);const gDT=(k:string,v:any):string=>{if(Array.isArray(v)){const iT=gDT(k,v[0]);if(iT.includes('Map')){const nC=k.charAt(0).toUpperCase()+k.slice(1,-1);gDCF(JSON.stringify(v[0]),o,nC,gC);return`List<${nC}>`;}return`List<${iT}>`;}if(typeof v==='object'&&v!==null){let nC=k.charAt(0).toUpperCase()+k.slice(1);nC=sS(nC);gDCF(JSON.stringify(v),o,nC,gC);return nC;}switch(typeof v){case'string':return'String';case'number':return o.numForNumber?'num':v%1===0?'int':'double';case'boolean':return'bool';default:return'dynamic';}};const gP=(j:any,p:string=''):string=>{return Object.entries(j).map(([k,v])=>{let t=gDT(k,v);if(o.n&&!o.m&&t!=='dynamic')t+='?';const fP=o.f?'final ':'';k=sS(k);return`  ${fP}${t} ${p}${k};`;}).join('\n');};let dC=`class ${cN} {\n`;dC+=gP(jO)+'\n\n';dC+=`  ${cN}({\n`;dC+=Object.keys(jO).map(k=>{const rP=o.m||!o.n?'required ':'';k=sS(k);return`    ${rP}this.${k},`;}).join('\n');dC+=`\n  });\n\n`;if(o.p){dC+=`  factory ${cN}.fromJson(Map<String, dynamic> json) {\n`;dC+=`    return ${cN}(\n`;dC+=Object.entries(jO).map(([k,v])=>{const t=gDT(k,v);let lK=sS(k);if(t.includes('List<Map')){const iT=t.match(/List<(\w+)>/)![1];return`      ${lK}: (json['${k}'] as List<dynamic>).map((item: any) => ${iT}.fromJson(item)).toList(),`;}else if(t===k.charAt(0).toUpperCase()+k.slice(1)){return`      ${lK}: ${t}.fromJson(json['${k}']),`;}return`      ${lK}: json['${k}'],`;}).join('\n');dC+=`\n    );\n  }\n\n`;dC+=`  Map<String, dynamic> toJson() {\n`;dC+=`    return {\n`;dC+=Object.entries(jO).map(([k,v])=>{const t=gDT(k,v);let rK=sS(k);if(t.includes('List<Map')){if(o.n&&!o.m){return`      '${k}': ${rK}.map((item: any) => item?.toJson()).toList(),`;}return`      '${k}': ${rK}.map((item: any) => item.toJson()).toList(),`;}else if(t===k.charAt(0).toUpperCase()+k.slice(1)){if(o.n&&!o.m){return`      '${k}': ${rK}?.toJson(),`;}return`      '${k}': ${rK}.toJson(),`;}return`      '${k}': ${rK},`;}).join('\n');dC+=`\n    };\n  }\n`;}if(o.g){dC+=`  ${cN} copyWith({\n`;dC+=Object.entries(jO).map(([k,v])=>{let t=gDT(k,v);k=sS(k);if(t==='dynamic'){return`    ${t} ${k},`;}return`    ${t}? ${k},`;}).join('\n');dC+=`\n  }) {\n    return ${cN}(\n`;dC+=Object.keys(jO).map(k=>{k=sS(k);return`      ${k}: ${k} ?? this.${k},`}).join('\n');dC+=`\n    );\n  }\n`;}dC+=`}\n`;if(gC.has(cN)){let nO:Map<string,any>=gC.get(cN)!.j;if(nO){jO={...nO,...jO};}}else{gC.set(cN,{dC,j:jO,});}const i=Array.from(gC.values()).map(({dC})=>dC).reverse().join('\n');return i;}export default gDCF;
